<html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><meta content="Adrian Smith" name="author" /><link href="membrane-topics/favicon.ico" rel="icon" /><title>Membrane Topics</title><link href="membrane-topics/bootstrap.min.css" rel="stylesheet" /><link href="membrane-topics/blog.css" rel="stylesheet" /><style type="text/css">.syntax pre {
  background: ;
}

.syntax pre .definition {
  color: #00f;
}

.syntax pre .core-fn {
  color: #30a;
}

.syntax pre .variable {
  color: black;
}

.syntax pre .number {
  color: #164;
}

.syntax pre .s-exp {
  color: #997;
}

.syntax pre .special-form {
  color: #30a;
}

.syntax pre .string {
  color: #a11;
}

.syntax pre .keyword {
  color: #708;
}

.syntax pre .macro {
  color: #05a;
}

.syntax pre .reader-char {
  color: #555;
}

.syntax pre .nil {
  color: #164;
}

.syntax pre .comment {
  color: #a50;
}

.syntax pre .repeat {
  color: #f00;
}

.syntax pre .regex {
  color: #f50;
}

.syntax pre .exception {
  color: #f00;
}

.syntax pre .boolean {
  color: #164;
}

.syntax pre .character {
  color: #f50;
}

.syntax pre .conditional {
  color: #30a;
} div.syntax { padding: 4px ; background-color: #f8f8f8; margin-bottom: 18px } div.syntax pre { margin-bottom: 0 }</style></head><body><div class="blog-masthead"><div class="container"><nav class="nav blog-nav"><a class="nav-link" href="https://github.com/phronmophobic/membrane">Membrane Github</a></nav></div></div><div class="blog-header"><div class="container"><h1 class="blog-title">Membrane Topics</h1><p class="lead blog-description"></p></div></div><div class="container"><div class="row"><div class="col-sm-8 blog-main"><div class="blog-post"><div><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Overview">Overview</a></li><li><a href="#Layout">Layout</a></li><li><a href="#Effect-Handlers">Effect Handlers</a></li><ul><li><a href="#Plugging-your-own-Effect-Handler">Plugging your own Effect Handler</a></li><li><a href="#Modeling-User-Intents">Modeling User Intents</a></li></ul><li><a href="#Defui-Components">Defui Components</a></li><ul><li><a href="#Background">Background</a></li><li><a href="#Component-State">Component State</a></li><li><a href="#EssentialIncidental-State">Essential/Incidental State</a></li><li><a href="#PublicPrivate-State">Public/Private State</a></li><li><a href="#Contextual-State">Contextual State</a></li><li><a href="#Defui-Limitations">Defui Limitations</a></li><li><a href="#Advanced-Usage">Advanced Usage</a></li><ul><li><a href="#Components-as-Values">Components as Values</a></li><li><a href="#Explicitly-Providing-References">Explicitly Providing References</a></li><li><a href="#Incidental-State-Identity">Incidental State Identity</a></li></ul></ul><li><a href="#Life-Cycle">Life Cycle</a></li><ul><li><a href="#Effects-on-State-Transition">Effects on State Transition</a></li><li><a href="#Effects-on-Mounting-or-Unmounting">Effects on "Mounting" or "Unmounting"</a></li><ul><li><a href="#Wrap-App">Wrap App</a></li><ul><li><a href="#Some-Caveats">Some Caveats</a></li></ul><li><a href="#add-watch">add-watch</a></li><li><a href="#Summary">Summary</a></li></ul></ul><li><a href="#Handling-Errors-in-Rendering-and-Drawing">Handling Errors in Rendering and Drawing</a></li><li><a href="#Backends">Backends</a></li><ul><li><a href="#Skia">Skia</a></li><li><a href="#java2dSwing">java2d/Swing</a></li><li><a href="#WebGL">WebGL</a></li><li><a href="#Other-Backends">Other Backends</a></li><li><a href="#Multi-Backend-Apps">Multi Backend Apps</a></li></ul><li><a href="#Thread-Safety-and-Background-Threads">Thread Safety and Background Threads</a></li><li><a href="#Optimization">Optimization</a></li><ul><li><a href="#Drawing">Drawing</a></li><li><a href="#Event-Handling">Event Handling</a></li><ul><li><a href="#Key-Events">Key Events</a></li></ul><li><a href="#Optimizing-Layout">Optimizing Layout</a></li></ul></ul><h1 id="Introduction">Introduction</h1><p><em>We&apos;re still figuring out best practices for membrane. If you tried one of these methods, please report back! Even if it didn&apos;t work, it would be good learn from the experience.</em></p><p>The following documents how to use membrane organized by topic. Each section is standalone. Feel free to scan, skip, or jump to any topic.</p><h1 id="Overview">Overview</h1><p><img alt="Overview" src="membrane-topics/overview-01.png" style="max-width: 90vw;height:auto" /></p><p><strong>View Function</strong> - A pure function which receives the relevant application state as an argument and returns data specifying <em>what</em> to draw (how to draw the data will be provided elsewhere).</p><p><strong>View</strong>: Data describing what to present to the user.</p><p><strong>Event Function</strong>: A pure function which receives a view and an event and returns data specifying the user&apos;s intent.</p><p><strong>Intent</strong>: Data representing a user intent. Examples of user intents are &quot;delete a todo list item&quot;, &quot;open a document&quot;, &quot;navigate to a URL&quot;.</p><p><strong>Effect Handler</strong>: An impure function that receives intents and should process these intents by affecting the world.</p><p><strong>Effect</strong>: The carrying out of an intent.</p><h1 id="Layout">Layout</h1><p>Membrane doesn&apos;t enforce any particular layout method. The main reason is that there&apos;s no need to. The flexibility comes from using immutable values. Most UI libraries rely on an underlying mutable, object-oriented system. In a mutable world, it&apos;s very difficult to paint a consistent picture of the world. In order to make the problem tractable, UI libraries are typically single threaded. Further, layout must happen at just the right time to capture a consistent snapshot before painting. These constraints mean that layout is managed by the UI library. Since layout is managed by the library, the library has to try and decide ahead of time what kinds of layouts it will support. Mutability can box a system into a series of unfortunate decisions leading to brittle and frustrating programs.</p><p>On the flip side, if views are values, it doesn&apos;t matter when layout happens. If it doesn&apos;t matter when layout happens, then the UI library doesn&apos;t have to choose ahead of time what layout systems should be supported.</p><p>Ok, so membrane doesn&apos;t have pre-ordained, blessed layout system. Good to know, but views still need some layout. What are the options for layout in membrane?</p><p>Layout is primarily about arranging views in space. A fundamental part of arranging views is measurement (ie. determining the width and height of a view). In membrane, the size of a view can be determined with <code>membrane.ui/bounds</code> which returns a two element vector of width and height, <code>[width, height]</code>. The <code>width</code> and <code>height</code> is with respect to the origin of the view which can be found with <code>membrane.ui/origin</code> (returns a two element vector of <code>[origin-x, origin-y]</code>). An important design goal for membrane was that measurement is just a regular, pure function. Measurement shouldn&apos;t require a special thread or any special context. Fortunately, clojure&apos;s emphasis on immutability makes it easy.</p><p>If measurement is just a pure function, then layout is also a pure function and normal functional techniques apply. Layout isn&apos;t special.</p><p>As an example, let&apos;s take a look at <code>membrane.ui/center</code>.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">center</span>
  <span class="string">"Centers `elem` within a space of `[width, height]`"</span>
  <span class="s-exp">[</span><span class="symbol">elem</span> <span class="s-exp">[</span><span class="symbol">width</span> <span class="symbol">height</span><span class="s-exp">]</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">ewidth</span> <span class="symbol">eheight</span><span class="s-exp">]</span> <span class="s-exp">(</span><span class="symbol">bounds</span> <span class="symbol">elem</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">translate</span> <span class="s-exp">(</span><span class="core-fn">int</span> <span class="s-exp">(</span><span class="core-fn">-</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">width</span> <span class="number">2</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">ewidth</span> <span class="number">2</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
               <span class="s-exp">(</span><span class="core-fn">int</span> <span class="s-exp">(</span><span class="core-fn">-</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">height</span> <span class="number">2</span><span class="s-exp">)</span>
                       <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">eheight</span> <span class="number">2</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
               <span class="symbol">elem</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The <code>membrane.ui/center</code> function is just a normal function for arranging elements. In addition to <code>center</code>, <code>membrane.ui</code> also includes <code>vertical-layout</code>, <code>horizontal-layout</code>, and <code>table-layout</code>. More layout helpers will be added. Layout is an area where third party library can shine.</p><h1 id="Effect-Handlers">Effect Handlers</h1><p>Membrane intentionally doesn&apos;t say a lot about how effect handling should be done. Each application should decide how effect handling should be done for its particular use case. There is no reason to couple effect handling to a specific UI library. Effect handling is a general problem. Any library that helps should work when building a user interface.</p><h2 id="Plugging-your-own-Effect-Handler">Plugging your own Effect Handler</h2><p>So what is an effect handler? Membrane apps are created using <code>membrane.component/make-app</code>. A custom handler can be provided by passing a function as the third argument. If the handler is <code>nil</code> or not provided, than the default effect handler will be used. A hander is function that will receive one argument, a sequence of intents.</p><p>Let&apos;s start with an example of using a custom effect handler.</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-counter</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="core-fn">num</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/on</span>
   <span class="keyword">:mouse-down</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
     <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:inc</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="core-fn">num</span> <span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-handler</span> <span class="core-fn">prn</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-app</span> <span class="s-exp">(</span><span class="symbol">component/make-app</span> <span class="reader-char">#'</span><span class="symbol">my-counter</span>
                                <span class="s-exp">{</span><span class="keyword">:num</span> <span class="number">0</span><span class="s-exp">}</span>
                                <span class="symbol">my-handler</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="macro">comment</span>
  <span class="s-exp">(</span><span class="symbol">backend/run</span> <span class="symbol">my-app</span><span class="s-exp">)</span>
  ,<span class="s-exp">)</span>

</pre></div><p>When you run <code>my-app</code>. You see that it will print <code>([:inc [(keypath :num)]])</code> whenever you click on the label.</p><h2 id="Modeling-User-Intents">Modeling User Intents</h2><p>The purpose of the event function is to translate raw user inputs like mouse and key events into user intents. The user intents are then passed to the effect handler to carry them out. For small applications, the separation of the event function and effect handler isn&apos;t that important. However, as an application grows, it&apos;s useful to be able to take an application apart for debugging, testing, development, etc.</p><p>The goal for modeling an intent is to describe <em>what</em> the user wants rather than <em>how</em> to do it. As an example, the resulting intent for clicking the checkbox on a todo item might look something like one of the following:</p><ul><li><p><code>[:update $complete? not]</code></p></li><li><p><code>[:toggle $complete?]</code></p></li><li><p><code>[::toggle-complete $todo]</code></p></li></ul><p>I&apos;m still not sure which version should be preferred and it might depend on the application. Let&apos;s consider some of the tradeoffs.</p><p>Pros and cons for the <code>:update</code> version:</p><ul><li><p>üëç More direct</p></li><li><p>üëé Highly coupled to a specific implementation</p></li><li><p>üëé Harder to instrument and wrap</p></li><li><p>üëç Doesn&apos;t require a specific effect handler</p></li></ul><p>Pros and cons for the <code>:toggle</code> version:</p><ul><li><p>üëç Direct</p></li><li><p>üëç Not coupled to a specific implementation</p></li><li><p>üëé Slightly harder to instrument and wrap</p></li><li><p>üëç Doesn&apos;t require a specific effect handler</p></li></ul><p>Pros and cons for the <code>::toggle-complete</code> version:</p><ul><li><p>üëé Indirect</p></li><li><p>üëç Not coupled to a specific implementation</p></li><li><p>üëç Easier to instrument and wrap</p></li><li><p>üëé Requires a specific effect handler</p></li></ul><p>Just counting the number of üëç and üëé may make it seem like <code>:toggle</code> is the winner, but I think the answer is more subtle.</p><p>For most use cases, <code>:toggle</code> strikes a good balance between cohesion, decoupling, and directness.</p><p>However, for small apps, it can be useful to have the implementation colocated with the component. For large apps, it my be useful to have more decoupling and more hooks for instrumentation, debugging, and cross-cutting concerns.</p><h1 id="Defui-Components">Defui Components</h1><p>Components are sugar. You can build user interfaces with only regular functions (this is more or less what <a href="https://elm-lang.org/">elm</a> does). The purpose of <code>defui</code> is to package some common features together for ease of use. <code>defui</code> components will work with non <code>defui</code> components and even within other state management systems.</p><h2 id="Background">Background</h2><p>When designing an interface, I like to start with pencil and paper. Stepping away from the keyboard helps focus on the fundamentals of the problem rather than whatever programming environment I&apos;m in. If you imagine what a pencil and paper design for a todo list component might look like, it might look something like:</p><pre><code>(add todo) | type here | 

- [X] drink coffee
- [ ] write documentation
- [ ] write tests
</code></pre><p>Given only this shorthand, most programmers could turn this into a functioning prototype. Since that&apos;s the case, would it be possible to have a sufficiently smart compiler (or macro) turn the shorthand into a working program? If not, what details are missing from the shorthand?</p><p>That&apos;s the background for the inspiration of <code>defui</code>. Here&apos;s what the above todo list looks like in membrane:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defeffect</span> <span class="keyword">:add-todo</span> <span class="s-exp">[</span><span class="symbol">$todos</span> <span class="symbol">next-todo</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">dispatch!</span> <span class="keyword">:update</span> <span class="symbol">$todos</span> <span class="core-fn">conj</span> <span class="s-exp">{</span><span class="keyword">:description</span> <span class="symbol">next-todo</span>
                                  <span class="keyword">:complete?</span> <span class="boolean">false</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-todo-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">todos</span> <span class="symbol">next-todo</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/vertical-layout</span>
   <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
    <span class="s-exp">(</span><span class="symbol">basic/button</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="string">"add todo"</span>
                   <span class="keyword">:on-click</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
                               <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:add-todo</span> <span class="symbol">$todos</span> <span class="symbol">next-todo</span><span class="s-exp">]</span>
                                <span class="s-exp">[</span><span class="keyword">:set</span> <span class="symbol">$next-todo</span> <span class="string">""</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">}</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="symbol">basic/textarea</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="symbol">next-todo</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>

   <span class="s-exp">(</span><span class="core-fn">apply</span>
    <span class="symbol">ui/vertical-layout</span>
    <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">complete?</span> <span class="symbol">description</span><span class="s-exp">]</span><span class="s-exp">}</span> <span class="symbol">todos</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
       <span class="s-exp">(</span><span class="symbol">basic/checkbox</span> <span class="s-exp">{</span><span class="keyword">:checked?</span> <span class="symbol">complete?</span><span class="s-exp">}</span><span class="s-exp">)</span>
       <span class="s-exp">(</span><span class="symbol">basic/textarea</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="symbol">description</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">skia/run</span> <span class="s-exp">(</span><span class="symbol">component/make-app</span> <span class="reader-char">#'</span><span class="symbol">my-todo-component</span> <span class="s-exp">{</span><span class="keyword">:todos</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:complete?</span> <span class="boolean">true</span>
                                                            <span class="keyword">:description</span> <span class="string">"drink coffee"</span><span class="s-exp">}</span><span class="s-exp">]</span>
                                                   <span class="keyword">:next-todo</span> <span class="string">""</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>It&apos;s definitely more verbose, but it&apos;s not too bad. One of the key ideas behind <code>defui</code> is that the checkbox call, <code>(basic/checkbox {:checked? complete?})</code>, doesn&apos;t require writing any code, callback, or specific event handler in order to know how to update the <code>:complete?</code> boolean of the todo item.</p><h2 id="Component-State">Component State</h2><p>On top of trying to match the mental model of how we tend to think about user interfaces, there were few additional design goals:</p><ol><li><p>No side effects in view or event functions</p></li><li><p>Receive data only through function arguments</p><ul><li><p>corollary: No hidden/local state and don&apos;t use global state</p></li></ul></li></ol><p>Along with functional programming techniques, the clojure ecosystem provides strong support for avoiding side effects. The main challenge when designing <code>defui</code> was making it easy to support all the state required to build a real user interface without cheating. User interfaces do have lots of state. It&apos;s worth taking a deeper look at the kinds of state user interfaces commonly require.</p><p>For our purposes, we&apos;ll separate the kinds of state we require into three dimensions:</p><ol><li><p>essential/incidental state</p></li><li><p>public/private state</p></li><li><p>contextual/non-contextual state</p></li></ol><p>To make things a bit more concrete, we&apos;ll use a text input as our example component. If you&apos;re ever trying to evaluate a UI state management solution, I highly recommend implementing a text input from scratch. I know that most platforms provide a builtin text input option, but implementing the text input yourself should provide a good testing ground for the support of the different types of state.</p><h2 id="EssentialIncidental-State">Essential/Incidental State</h2><p>Usually, the essential state for a text input is the text itself. Typically, the cursor position, text selection, focus, etc. are all incidental. As long as the user can edit the text, that&apos;s the only thing the application cares about. However, sometimes the application does care about the text selection, focus, or the cursor. A key insight is that component properties aren&apos;t inherently incidental. Whether or not a property is incidental depends on the application! It is a mistake for the component author to decide which state is incidental and which state is essential.</p><h2 id="PublicPrivate-State">Public/Private State</h2><p>Another lens to view state is whether or not the state is public or private. A component author may want to have some state, but not make any promises about its structure or that it will remain consistent across versions of the component. For our text input example, the cursor, text selection, and focus might be public, but the text input might want to have a private internal representation of the text, data about the current mouse position used for text selection, internal timing data related to double clicks, spellcheck, etc. By definition, private state is incidental, but public state may or may not be incidental depending on the use case. However, even if some state is incidental, it may be useful for the application to treat the state as an opaque value for debugging, testing, or otherwise.</p><h2 id="Contextual-State">Contextual State</h2><p>Contextual state is shared for a whole branch of a component tree. The most common example is focus. Only one component can have focus and receive key events. Since contextual state is shared across many components, it shouldn&apos;t be overused. Too much contextual state can have negative performance implications. Similar to global state, contextual state can also introduce unnecessary coupling and make it harder to reason about components.</p><p>However, supporting contextual state is important because sometimes it is the right tool for the job. Some other examples of contextual state:</p><ul><li><p>For drag and drop, there can only be one currently selected drag object and any component could potentially be a drop target.</p></li><li><p>Modals and right click menus can have at most one instance visible per window.</p></li><li><p>Contextual state can be useful for passing styling info to a whole tree of components (eg. dark mode)</p></li></ul><h2 id="Defui-Limitations">Defui Limitations</h2><p>Defui tries to reduce boilerplate by wiring incidental state and context. It does this by automatically passing any incidental state to calls to other <code>defui</code> components as well as replacing any binding that that starts with a <code>$</code> with a corresponding reference. As long as a binding derives from a component&apos;s arguments, a valid reference should be possible. However there are a few limitations.</p><p>Each binding derived from a component argument can only be derived one function call at a time.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">my-prop</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="comment">;; ok
</span>        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="keyword">:foo</span> <span class="symbol">my-prop</span><span class="s-exp">)</span>

        <span class="comment">;; multiple calls not supported
</span>        <span class="symbol">baz</span> <span class="s-exp">(</span><span class="keyword">:baz</span> <span class="s-exp">(</span><span class="keyword">:biz</span> <span class="symbol">my-prop</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>

    <span class="s-exp">(</span><span class="symbol">my-other-component</span> <span class="s-exp">{</span><span class="keyword">:foo</span> <span class="symbol">foo</span>
                         <span class="keyword">:bar</span> <span class="symbol">bar</span>
                         <span class="keyword">:baz</span> <span class="symbol">baz</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The <code>defui</code> macro supports many common data operations, but it&apos;s currently not an open set. The following data operations are supported:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">my-prop</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="comment">;; these work
</span>        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="keyword">:foo</span> <span class="symbol">my-prop</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="keyword">:foo</span> <span class="symbol">my-prop</span> <span class="keyword">:my-default</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="core-fn">nth</span> <span class="symbol">my-prop</span> <span class="number">0</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="core-fn">nth</span> <span class="symbol">my-prop</span> <span class="number">0</span> <span class="keyword">:my-default</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="core-fn">get-in</span> <span class="symbol">my-prop</span> <span class="s-exp">[</span><span class="keyword">:foo</span> <span class="keyword">:bar</span><span class="s-exp">]</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="core-fn">get-in</span> <span class="symbol">my-prop</span> <span class="s-exp">[</span><span class="keyword">:foo</span> <span class="keyword">:bar</span><span class="s-exp">]</span> <span class="keyword">:my-default</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="core-fn">take</span> <span class="number">42</span> <span class="symbol">my-prop</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="core-fn">drop</span> <span class="number">42</span> <span class="symbol">my-prop</span><span class="s-exp">)</span>
        <span class="symbol">foo</span> <span class="s-exp">(</span><span class="macro">or</span> <span class="symbol">my-prop</span> <span class="number">42</span><span class="s-exp">)</span>
        
        <span class="comment">;; destructuring also works
</span>        <span class="s-exp">{</span><span class="symbol">foo</span> <span class="keyword">:foo</span>
         <span class="symbol">bar</span> <span class="keyword">:bar</span>
         <span class="s-exp">[</span><span class="symbol">a</span> <span class="symbol">b</span> <span class="reader-char">&</span> <span class="symbol">other-foos</span><span class="s-exp">]</span> <span class="keyword">:foos</span><span class="s-exp">}</span> <span class="symbol">my-prop</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="symbol">my-other-component</span> <span class="s-exp">{</span><span class="keyword">:foo</span> <span class="symbol">foo</span>
                         <span class="keyword">:bar</span> <span class="symbol">bar</span>
                         <span class="keyword">:a</span> <span class="symbol">a</span>
                         <span class="keyword">:b</span> <span class="symbol">b</span>
                         <span class="keyword">:other-foos</span> <span class="symbol">other-foos</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>In addition to the above data operations, there is special support for the <code>for</code> comprehension.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">my-prop</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">apply</span>
   <span class="symbol">ui/vertical-layout</span>
   <span class="comment">;; works
</span>   <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">k</span> <span class="symbol">v</span><span class="s-exp">]</span> <span class="symbol">my-prop</span>
         <span class="keyword">:let</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="symbol">a</span> <span class="keyword">:my-a</span>
                <span class="symbol">b</span> <span class="keyword">:my-b</span><span class="s-exp">}</span> <span class="symbol">v</span><span class="s-exp">]</span>
         <span class="keyword">:while</span> <span class="symbol">a</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="symbol">my-other-component</span> <span class="s-exp">{</span><span class="keyword">:v</span> <span class="symbol">v</span>
                          <span class="keyword">:a</span> <span class="symbol">a</span>
                          <span class="keyword">:b</span> <span class="symbol">b</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The <code>map</code> function is not supported.</p><div class="syntax"><pre>  
<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">my-props</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">apply</span>
   <span class="symbol">ui/vertical-layout</span>
   <span class="comment">;; doesn't work
</span>   <span class="s-exp">(</span><span class="core-fn">map</span> <span class="symbol">other-component</span> <span class="symbol">my-props</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The <code>defui</code> macro detects calls to other <code>defui</code> components to thread the incidental state by looking at the metadata of the resolved var. That means that if symbol that represents the component function wouldn&apos;t be resolved to the var, then the function call will be treated like a normal function call and the incidental state won&apos;t be added.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">my-prop</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">f</span> <span class="symbol">basic/textarea</span><span class="s-exp">]</span>
    <span class="comment">;; incidental state not added
</span>    <span class="s-exp">(</span><span class="symbol">f</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="symbol">my-prop</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>In some cases, the component won&apos;t be known (or even exist) at compile time. In those cases, then all of the state can be provided manually. Better support is  <a href="https://github.com/phronmophobic/membrane/issues/61">planned</a>.</p><h2 id="Advanced-Usage">Advanced Usage</h2><p>Defui components are designed to be used mostly like regular functions, while also taking care of incidental state and context so you don&apos;t have to. For some less common use cases, it&apos;s useful to reuse existing components, but manually wire them together.</p><h3 id="Components-as-Values">Components as Values</h3><p>Functions defined by <code>defui</code> return records. They can be used similar to normal map-like values. For example, using the definition from <code>membrane.example.todo/todo-app</code>, the component can be inspected, reused, measured, copied, drawn, etc.</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-app</span> <span class="s-exp">(</span><span class="symbol">membrane.example.todo/todo-app</span>
             <span class="s-exp">{</span><span class="keyword">:todos</span>
              <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:complete?</span> <span class="boolean">false</span>
                <span class="keyword">:description</span> <span class="string">"first"</span><span class="s-exp">}</span>
               <span class="s-exp">{</span><span class="keyword">:complete?</span> <span class="boolean">false</span>
                <span class="keyword">:description</span> <span class="string">"second"</span><span class="s-exp">}</span>
               <span class="s-exp">{</span><span class="keyword">:complete?</span> <span class="boolean">true</span>
                <span class="keyword">:description</span> <span class="string">"third"</span><span class="s-exp">}</span><span class="s-exp">]</span>
              <span class="keyword">:next-todo-text</span> <span class="string">""</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="comment">;; find a mouse coordinate that toggles a todo
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">toggle-checkbox?</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">intent-type</span> <span class="reader-char">&</span> <span class="symbol">_</span><span class="s-exp">]</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">=</span> <span class="keyword">:membrane.basic-components/toggle</span>
     <span class="symbol">intent-type</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="macro">->></span> <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="symbol">x</span> <span class="s-exp">(</span><span class="core-fn">range</span> <span class="number">300</span><span class="s-exp">)</span>
           <span class="symbol">y</span> <span class="s-exp">(</span><span class="core-fn">range</span> <span class="number">300</span><span class="s-exp">)</span><span class="s-exp">]</span>
       <span class="s-exp">[</span><span class="symbol">x</span> <span class="symbol">y</span><span class="s-exp">]</span><span class="s-exp">)</span>
     <span class="s-exp">(</span><span class="core-fn">some</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">pos</span><span class="s-exp">]</span>
             <span class="s-exp">(</span><span class="conditional">when</span> <span class="s-exp">(</span><span class="core-fn">some</span> <span class="symbol">toggle-checkbox?</span>
                         <span class="s-exp">(</span><span class="symbol">ui/mouse-down</span> <span class="symbol">my-app</span> <span class="symbol">pos</span><span class="s-exp">)</span><span class="s-exp">)</span>
               <span class="symbol">pos</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="comment">;; [26 72]
</span>
<span class="comment">;; save image of my-app with 10px padding
</span><span class="s-exp">(</span><span class="symbol">skia/save-image</span> <span class="string">"my-app.png"</span> <span class="s-exp">(</span><span class="symbol">ui/padding</span> <span class="number">10</span> <span class="symbol">my-app</span><span class="s-exp">)</span> <span class="s-exp">)</span>
<span class="comment">;; same as above, but mark the first todo complete
</span><span class="s-exp">(</span><span class="symbol">skia/save-image</span> <span class="string">"my-app2.png"</span> <span class="s-exp">(</span><span class="symbol">ui/padding</span> <span class="number">10</span> <span class="s-exp">(</span><span class="core-fn">update-in</span> <span class="symbol">my-app</span> <span class="s-exp">[</span><span class="keyword">:todos</span> <span class="number">0</span> <span class="keyword">:complete?</span><span class="s-exp">]</span> <span class="core-fn">not</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="comment">;; Open a window with the current view of the app
</span><span class="comment">;; side by side with the same app having a different
</span><span class="comment">;; filter selected
</span><span class="s-exp">(</span><span class="symbol">skia/run</span>
  <span class="s-exp">(</span><span class="core-fn">constantly</span>
   <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
    <span class="symbol">my-app</span>
    <span class="s-exp">(</span><span class="core-fn">assoc</span> <span class="symbol">my-app</span> <span class="keyword">:selected-filter</span> <span class="keyword">:active</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>


<span class="comment">;; Find text in my-app
</span><span class="s-exp">(</span><span class="macro">->></span> <span class="s-exp">(</span><span class="core-fn">tree-seq</span> <span class="symbol">ui/children</span> <span class="symbol">ui/children</span> <span class="symbol">my-app</span><span class="s-exp">)</span>
     <span class="s-exp">(</span><span class="core-fn">keep</span> <span class="keyword">:text</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="comment">;; ("Add Todo" "Add Todo" "" "" "" "" "all" "active" "complete?" "first" "first" "first" "first" "second" "second" "second" "second" "third" "third" "third" "third")
</span>
</pre></div><h3 id="Explicitly-Providing-References">Explicitly Providing References</h3><p>The way the <code>defui</code> macro produces references is that it keeps track of how bindings are derived from function arguments. For this to work, the reference path for each argument must be provided to each call to a <code>defui</code> component. The path key for a given property is just the keyword with a <code>$</code> prefix. For example, for a call to <code>(basic/textarea {:text &quot;foo&quot;})</code>, the reference key is <code>:$foo</code>. The <code>defui</code> macro will add this extra info for you, but it may be useful to provided it explicitly, <code>(basic/textarea {:text &quot;foo&quot; :$text foo-ref})</code>.</p><h3 id="Incidental-State-Identity">Incidental State Identity</h3><p>When a property isn&apos;t explicitly provided to a <code>defui</code> component call, then it is assumed to be incidental state. The incidental state will automatically be added for you by the <code>defui</code> macro. However, the state must be stored <em>somewhere</em>. Further, the place where the state is stored must be stable so that when the view tree is reconstructed, the same state gets passed to the same logical component even if some views have shifted a bit. In react, the process of matching local state with a component is called <a href="https://reactjs.org/docs/reconciliation.html">reconciliation</a>. Membrane doesn&apos;t have local state in the same way as React, but the process of matching incidental state with a component is fairly similar. Generally, react reconciles components based on the structure of the DOM. Using the structure of the DOM is fairly crude, but react provides another option for find a logically stable way to reconcile data, &quot;The developer can hint at which child elements may be stable across different renders with a key prop.&quot; This is essentially what membrane does for you. To reconcile component state across renders, membrane generates a key based on the identities of the properties that are explicitly provided to a component.</p><p>For example, if you have a component that uses a textarea like <code>(basic/textarea {:text s})</code>, then the key for the incidental state you don&apos;t care about (like cursor position, selection, etc), is logically equivalent to the reference for <code>s</code>, since that&apos;s the property that was explicitly provided. If the textarea shifts in the view tree, it will still get the same incidental state associated with the identity of <code>s</code>.</p><p>Usually, this works as expected, but there are some cases where explicitly providing a key is needed. If you run the following example, you&apos;ll notice that all of the buttons share the same hover state. The reason is that they all have the same key for the incidental hover state. Since every button was passed the same exact props, membrane uses the same key for all of them.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">apply</span>
   <span class="symbol">ui/vertical-layout</span>
   <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="symbol">i</span> <span class="s-exp">(</span><span class="core-fn">range</span> <span class="number">10</span><span class="s-exp">)</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
      <span class="s-exp">(</span><span class="symbol">basic/button</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="string">"send"</span><span class="s-exp">}</span><span class="s-exp">)</span>
      <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="s-exp">(</span><span class="core-fn">str</span> <span class="string">"num: "</span> <span class="symbol">i</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">skia/run</span> <span class="s-exp">(</span><span class="symbol">component/make-app</span> <span class="reader-char">#'</span><span class="symbol">my-component</span> <span class="s-exp">{</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>The fix in this example is to explicitly provide a key to differentiate the different buttons. The key that we&apos;ll use to fix is <code>[:button i]</code>. The key is a little arbitrary. Logically, it should be related to <code>i</code> since that&apos;s the related value, but I also like to provide a related name (<code>:button</code> in this example). It usually doesn&apos;t matter, but it can be useful for debugging as well as prevent collisions if our component grows and adds another row of buttons somewhere.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">my-component</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">apply</span>
   <span class="symbol">ui/vertical-layout</span>
   <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="symbol">i</span> <span class="s-exp">(</span><span class="core-fn">range</span> <span class="number">10</span><span class="s-exp">)</span>
         <span class="keyword">:let</span> <span class="s-exp">[</span><span class="symbol">my-key</span> <span class="s-exp">[</span><span class="keyword">:button</span> <span class="symbol">i</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
      <span class="s-exp">(</span><span class="symbol">basic/button</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="string">"send"</span>
                     <span class="keyword">:extra</span> <span class="s-exp">(</span><span class="core-fn">get</span> <span class="symbol">extra</span> <span class="symbol">my-key</span><span class="s-exp">)</span><span class="s-exp">}</span><span class="s-exp">)</span>
      <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="s-exp">(</span><span class="core-fn">str</span> <span class="string">"num: "</span> <span class="symbol">i</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">skia/run</span> <span class="s-exp">(</span><span class="symbol">component/make-app</span> <span class="reader-char">#'</span><span class="symbol">my-component</span> <span class="s-exp">{</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><h1 id="Life-Cycle">Life Cycle</h1><p>React.js has various lifecycle methods that get called when &quot;mounting&quot; as well as updating state. One major difference between membrane components and react components is that react components are only useful for passing to the react framework. React components aren&apos;t meant to be called except within a very specific context managed by react. In contrast, membrane components are just regular, pure functions that can be called whenever, without any setup or particular context.</p><p>That&apos;s not to say that lifecycle methods don&apos;t make sense when using membrane, but their role shifts. It&apos;s also important to make sure that life cycle handlers don&apos;t impact usages outside of rendering.</p><p>There&apos;s no builtin support for lifecycle methods in membrane. I&apos;m still gathering use cases and trying to figure out what best practices might look like. However, I have some ideas on how to cover common uses cases.</p><h2 id="Effects-on-State-Transition">Effects on State Transition</h2><p>React has various life cycle methods that trigger on state updates, <a href="https://reactjs.org/docs/react-component.html#updating">https://reactjs.org/docs/react-component.html#updating</a>. Generally speaking, effects or updates that trigger on state transitions should be enforced by the application regardless of whether a user interface (or interfaces) are visible. Coupling the update with a particular UI component is bad practice. Below are some recommended ways to implement effects on state transitions:</p><ul><li><p>Add a watch (ie. <code>add-watch</code>) to your app&apos;s state atom. Perform the dependent computations in the watch callback when the relevant source data changes.</p></li><li><p>Provide your own handler to <code>membrane.component/make-app</code> to enforce constraints.</p></li></ul><h2 id="Effects-on-Mounting-or-Unmounting">Effects on &quot;Mounting&quot; or &quot;Unmounting&quot;</h2><p>In some cases, you may want to initiate effects either right before or after a component will be viewed by the user (eg. lazy image loading). It doesn&apos;t make sense to perform these functions when a component is called because components can be called not only when being displayed, but whenever (eg. testing, debugging, offscreen rendering, development, tooling, etc.).</p><p>Below is an example of how a mounting event could be implemented with membrane. Implementing unmounting would follow the same basic pattern and is left as an exercise for the reader.</p><div class="syntax"><pre><span class="s-exp">(</span><span class="definition">defprotocol</span> <span class="symbol">IOnPresent</span>
  <span class="keyword">:extend-via-metadata</span> <span class="boolean">true</span>  
  <span class="s-exp">(</span><span class="symbol">-on-present</span> <span class="s-exp">[</span><span class="symbol">elem</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="macro">extend-protocol</span> <span class="symbol">IOnPresent</span>
  <span class="nil">nil</span>
  <span class="s-exp">(</span><span class="symbol">-on-present</span> <span class="s-exp">[</span><span class="symbol">this</span><span class="s-exp">]</span> <span class="nil">nil</span><span class="s-exp">)</span>

  <span class="reader-char">#</span><span class="symbol">?</span><span class="s-exp">(</span><span class="keyword">:clj</span> <span class="symbol">Object</span>
     <span class="keyword">:cljs</span> <span class="symbol">default</span><span class="s-exp">)</span>
  <span class="s-exp">(</span><span class="symbol">-on-present</span> <span class="s-exp">[</span><span class="symbol">this</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="core-fn">mapcat</span> <span class="reader-char">#</span><span class="s-exp">(</span><span class="symbol">-on-present</span> <span class="keyword">%</span><span class="s-exp">)</span> <span class="s-exp">(</span><span class="symbol">ui/children</span> <span class="symbol">this</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>


<span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">present</span> <span class="s-exp">[</span><span class="symbol">elem</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">-on-present</span> <span class="symbol">elem</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">on-present</span> <span class="s-exp">[</span><span class="symbol">on-present</span> <span class="symbol">elem</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="core-fn">vary-meta</span> <span class="symbol">elem</span>
             <span class="core-fn">assoc</span> <span class="reader-char">`</span><span class="symbol">-on-present</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">_</span><span class="s-exp">]</span>
                                  <span class="s-exp">(</span><span class="symbol">on-present</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Example usage:</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">lazy-image</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">url</span> <span class="symbol">image-status</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">on-present</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
     <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">::load-image</span> <span class="symbol">$image-status</span> <span class="symbol">url</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">status</span>
                 <span class="symbol">img</span><span class="s-exp">]</span><span class="s-exp">}</span> <span class="symbol">image-status</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="special-form">if</span> <span class="symbol">img</span>
       <span class="s-exp">(</span><span class="symbol">ui/image</span> <span class="symbol">img</span><span class="s-exp">)</span>
       <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="s-exp">(</span><span class="special-form">if</span> <span class="symbol">status</span>
                   <span class="symbol">status</span>
                   <span class="string">"loading..."</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">defeffect</span> <span class="keyword">::load-image</span> <span class="s-exp">[</span><span class="symbol">$image-status</span> <span class="symbol">url</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">dispatch!</span> <span class="keyword">:update</span> <span class="symbol">$image-status</span>
             <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">image-status</span><span class="s-exp">]</span>
               <span class="s-exp">(</span><span class="special-form">if</span> <span class="s-exp">(</span><span class="macro">and</span> <span class="symbol">image-status</span>
                        <span class="s-exp">(</span><span class="core-fn">=</span> <span class="symbol">url</span> <span class="s-exp">(</span><span class="keyword">:url</span> <span class="symbol">image-status</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
                 <span class="symbol">image-status</span>
                 <span class="s-exp">{</span><span class="keyword">:url</span> <span class="symbol">url</span>
                  <span class="keyword">:fut</span> <span class="s-exp">(</span><span class="macro">future</span>
                         <span class="s-exp">(</span><span class="core-fn">println</span> <span class="string">"downloading"</span> <span class="symbol">url</span><span class="s-exp">)</span>
                         <span class="s-exp">(</span><span class="symbol">dispatch!</span> <span class="keyword">:update</span> <span class="symbol">$image-status</span> <span class="core-fn">assoc</span> <span class="keyword">:status</span> <span class="string">"downloading"</span><span class="s-exp">)</span>
                         <span class="s-exp">(</span><span class="macro">with-open</span> <span class="s-exp">[</span><span class="symbol">is</span> <span class="s-exp">(</span><span class="symbol">clojure.java.io/input-stream</span> <span class="symbol">url</span><span class="s-exp">)</span>
                                     <span class="symbol">out</span> <span class="s-exp">(</span><span class="symbol">java.io.ByteArrayOutputStream.</span><span class="s-exp">)</span><span class="s-exp">]</span>
                           <span class="s-exp">(</span><span class="symbol">clojure.java.io/copy</span> <span class="symbol">is</span> <span class="symbol">out</span><span class="s-exp">)</span>
                           <span class="s-exp">(</span><span class="symbol">dispatch!</span> <span class="keyword">:update</span> <span class="symbol">$image-status</span>
                                      <span class="core-fn">assoc</span>
                                      <span class="keyword">:status</span> <span class="string">"done!"</span>
                                      <span class="keyword">:img</span> <span class="s-exp">(</span><span class="symbol">.toByteArray</span> <span class="symbol">out</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">lazy-image-atm</span> <span class="s-exp">(</span><span class="core-fn">atom</span> <span class="s-exp">{</span><span class="keyword">:url</span> <span class="string">"https://clojure.org/images/clojure-logo-120b.png"</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>


<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">my-lazy-image</span> <span class="s-exp">(</span><span class="symbol">lazy-image</span> <span class="reader-char">@</span><span class="symbol">lazy-image-atm</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="reader-char">@</span><span class="symbol">lazy-image-atm</span>
<span class="comment">;; {:url "https://clojure.org/images/clojure-logo-120b.png"}
</span>
<span class="s-exp">(</span><span class="symbol">present</span> <span class="symbol">my-lazy-image</span><span class="s-exp">)</span>
<span class="comment">;; ([:membrane.example.todo/load-image [(keypath :img)] "https://clojure.org/images/clojure-logo-120b.png"])
</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">lazy-image-handler</span> <span class="s-exp">(</span><span class="symbol">component/default-handler</span> <span class="symbol">lazy-image-atm</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="symbol">lazy-image-handler</span> <span class="s-exp">(</span><span class="symbol">present</span> <span class="symbol">my-lazy-image</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="macro">-></span> <span class="reader-char">@</span><span class="symbol">lazy-image-atm</span>
    <span class="keyword">:image-status</span>
    <span class="s-exp">(</span><span class="core-fn">select-keys</span> <span class="s-exp">[</span><span class="keyword">:img</span> <span class="keyword">:status</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="comment">;; {:img #object["[B" 0x6bd0b106 "[B@6bd0b106"], :status "done!"}
</span>
</pre></div><p>There are various ways to support on <code>on-present</code> in your app.</p><h3 id="Wrap-App">Wrap App</h3><p>The backend <code>run</code> functions (eg. <code>membrane.skia/run</code>) accept a function that receives no arguments and returns a view. The common usage of <code>defui</code> apps is to build an app using <code>membrane.component/make-app</code> and pass that to the <code>run</code> function. The <code>present</code> event can be triggered by wrapping the app with a call to <code>present</code> before returning the resulting view.</p><p>An example of this method is below:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">defui</span> <span class="symbol">test-lazy-image</span> <span class="s-exp">[</span><span class="s-exp">{</span><span class="keyword">:keys</span> <span class="s-exp">[</span><span class="symbol">show?</span> <span class="symbol">url</span> <span class="symbol">next-url</span><span class="s-exp">]</span><span class="s-exp">}</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/vertical-layout</span>
   <span class="s-exp">(</span><span class="symbol">ui/horizontal-layout</span>
    <span class="s-exp">(</span><span class="symbol">basic/button</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="string">"download"</span>
                   <span class="keyword">:on-click</span> <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
                               <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:set</span> <span class="symbol">$url</span> <span class="symbol">next-url</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">}</span><span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="symbol">basic/textarea</span> <span class="s-exp">{</span><span class="keyword">:text</span> <span class="symbol">next-url</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">basic/checkbox</span> <span class="s-exp">{</span><span class="keyword">:checked?</span> <span class="symbol">show?</span><span class="s-exp">}</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="special-form">if</span> <span class="s-exp">(</span><span class="macro">and</span> <span class="symbol">show?</span> <span class="symbol">url</span><span class="s-exp">)</span>
     <span class="s-exp">(</span><span class="symbol">lazy-image</span> <span class="s-exp">{</span><span class="keyword">:url</span> <span class="symbol">url</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">lazy-image-test-atm</span> <span class="s-exp">(</span><span class="core-fn">atom</span> <span class="s-exp">{</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">test-lazy-image-app</span>
  <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">handler</span> <span class="s-exp">(</span><span class="symbol">component/default-handler</span> <span class="symbol">lazy-image-test-atm</span><span class="s-exp">)</span>
        <span class="symbol">app</span> <span class="s-exp">(</span><span class="symbol">component/make-app</span> <span class="reader-char">#'</span><span class="symbol">test-lazy-image</span> <span class="symbol">lazy-image-test-atm</span> <span class="symbol">handler</span><span class="s-exp">)</span><span class="s-exp">]</span>
    <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">ui</span> <span class="s-exp">(</span><span class="symbol">app</span><span class="s-exp">)</span><span class="s-exp">]</span>
        <span class="s-exp">(</span><span class="symbol">handler</span> <span class="s-exp">(</span><span class="symbol">present</span> <span class="symbol">ui</span><span class="s-exp">)</span><span class="s-exp">)</span>
        <span class="symbol">ui</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">skia/run</span> <span class="symbol">test-lazy-image-app</span><span class="s-exp">)</span>
</pre></div><p>The key features of this design are:</p><ul><li><p>Components like <code>lazy-image</code> are still pure.</p></li><li><p>Effects can be tested independently of the view</p></li><li><p>Contexts like debugging, testing, offscreen rendering, etc. are still supported.</p></li></ul><h4 id="Some-Caveats">Some Caveats</h4><p>There are currently no guarantees to how how many times a <code>run</code> function will the view function for each render. In practice, most backends can be expected to call the view function once per render. Depending on how best practices develop, it may make sense to require stronger guarantees from backends as to when and how often view functions are called. Another possibility is that the tools for building a backend might be simplified so it&apos;s easier for each application to build a backend that works exactly as needed while still offering good defaults.</p><p>The processing of the <code>present</code> event will happen on the main thread. However, it would be easy for an application to move the <code>present</code> event to background thread if desired.</p><h3 id="add-watch">add-watch</h3><p>Instead of augmenting the view function passed to a backend <code>run</code> function, another option is to trigger the <code>present</code> event within an <code>add-watch</code> callback.</p><p>Here&apos;s what that looks like.</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">lazy-image-test-atm</span> <span class="s-exp">(</span><span class="core-fn">atom</span> <span class="s-exp">{</span><span class="s-exp">}</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">lazy-image-handler</span> <span class="s-exp">(</span><span class="symbol">component/default-handler</span> <span class="symbol">lazy-image-test-atm</span><span class="s-exp">)</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">test-lazy-image-app</span> <span class="s-exp">(</span><span class="symbol">component/make-app</span> <span class="reader-char">#'</span><span class="symbol">test-lazy-image</span> <span class="symbol">lazy-image-test-atm</span> <span class="symbol">lazy-image-handler</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="core-fn">add-watch</span> <span class="symbol">lazy-image-test-atm</span> <span class="keyword">::present</span>
           <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">k</span> <span class="core-fn">ref</span> <span class="symbol">old</span> <span class="special-form">new</span><span class="s-exp">]</span>
             <span class="s-exp">(</span><span class="conditional">when</span> <span class="s-exp">(</span><span class="core-fn">not=</span> <span class="symbol">old</span> <span class="special-form">new</span><span class="s-exp">)</span>
               <span class="s-exp">(</span><span class="special-form">let</span> <span class="s-exp">[</span><span class="symbol">intents</span> <span class="s-exp">(</span><span class="symbol">present</span> <span class="s-exp">(</span><span class="macro">-></span> <span class="s-exp">(</span><span class="symbol">test-lazy-image-app</span><span class="s-exp">)</span>
                                          <span class="s-exp">(</span><span class="core-fn">assoc</span> <span class="keyword">:state</span> <span class="special-form">new</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
                 <span class="s-exp">(</span><span class="symbol">lazy-image-handler</span> <span class="symbol">intents</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">skia/run</span> <span class="symbol">test-lazy-image-app</span><span class="s-exp">)</span>
</pre></div><p>Differences between the <code>add-watch</code> approach and the app wrap approach:</p><ul><li><p>The <code>add-watch</code> method runs off the main thread.</p></li><li><p>The <code>add-watch</code> runs based solely off the state and doesn&apos;t require that the app is being run or viewed by a user.</p></li><li><p>The <code>add-watch</code> approach can potentially make updates before a frame is rendered to avoid flickering.</p></li></ul><h3 id="Summary">Summary</h3><p>Hopefully, one of the two example approaches provides a solution for your life-cycle event needs. If not, hopefully it shows an approach to implementing the right solution.</p><h1 id="Handling-Errors-in-Rendering-and-Drawing">Handling Errors in Rendering and Drawing</h1><p>Errors during layout and rendering can be caught using normal try/catch, but there may be cases where rendering succeeds, but an error is thrown during drawing that the application wants to catch.</p><p>The way to catch drawing exception is by wrapping a view with <code>membrane.ui/try-draw</code>. The <code>try-draw</code> function accepts an element to try and draw and a function that is called if an exception occurs. The function callback is weird by membrane standards because it is expected to be an impure function. It is called with two arguments, a <code>draw</code> function that can be used to draw an element and the exception that was thrown.</p><p>Example:</p><div class="syntax"><pre><span class="s-exp">(</span><span class="symbol">backend/run</span>
  <span class="s-exp">(</span><span class="core-fn">constantly</span>
   <span class="s-exp">(</span><span class="symbol">ui/try-draw</span> 
    <span class="s-exp">(</span><span class="symbol">ui/rectangle</span> <span class="string">"NaN"</span> <span class="string">"NaN"</span> <span class="s-exp">)</span>
    <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">draw</span> <span class="symbol">e</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="symbol">draw</span> <span class="s-exp">(</span><span class="symbol">ui/label</span> <span class="s-exp">(</span><span class="symbol">ex-message</span> <span class="symbol">e</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><p>Notice that the callback doesn&apos;t return a label, but draws it by calling <code>draw</code>.</p><h1 id="Backends">Backends</h1><h2 id="Skia">Skia</h2><p>The most polished backend is the <code>membrane.skia</code> backend. However, it requires native dependencies and currently only runs on Mac OSX and Linux. This is usually the backend I recommend if you&apos;re building a user interface for yourself.</p><h2 id="java2dSwing">java2d/Swing</h2><p>The second most polished backend is the <code>membrane.java2d</code> backend. It works on all desktop platforms and doesn&apos;t require any native dependencies. This is the backend I recommend if you&apos;re building a user interface for distributing to others.</p><h2 id="WebGL">WebGL</h2><p>The webGL backend is the most polished backend that runs in a web browser. However, since there are several high quality clojurescript libraries for building user interfaces on the web, membrane development on the desktop backends is prioritized over backends that run in the browser. Having said that, the webGL backend will continue to be fully supported.</p><h2 id="Other-Backends">Other Backends</h2><p>All of the other backends are experimental. If you&apos;d like a particular backend to receive more attention, please reach out!</p><h2 id="Multi-Backend-Apps">Multi Backend Apps</h2><p>Most of the membrane apps run on multiple backends with little to no tweaking. Making apps work exactly the same on all platforms is a non-goal, but behavior should be consistent across backends when reasonable. Additionally, making it easy for applications to fully leverage the underlying platform for each backend is a goal.</p><h1 id="Thread-Safety-and-Background-Threads">Thread Safety and Background Threads</h1><p>All public functions should be thread safe. Nothing special is required to do work in the background.</p><h1 id="Optimization">Optimization</h1><p>The goal for membrane is to act just like a regular clojure library. Layout, event handling, and effect handling are decoupled and can be run independently without any special setup.</p><p>One of the main tools for optimizing membrane user interfaces is memoization. Typically, the user is interacting with a subset of the screen at any given moment and everything else on the screen is mostly static. It&apos;s not like video games where every entity on the screen might be updated every frame. That makes memoization an effective option for user interfaces.</p><p>Membrane does some amount of memoization for you under the hood at the component level. If you&apos;re having performance problems, the first tip to try is refactoring large components into smaller components.</p><h2 id="Drawing">Drawing</h2><p>The three main techniques for optimizing drawing bottle necks are:</p><p>1. Cache complex draws using <code>membrane.ui/-&gt;Cached</code>.</p><p>If there is a section of the view tree that does a lot of drawing, but is mostly static, then wrapping the element with <code>ui/-&gt;Cached</code> can make a huge difference. The drawing implementation for <code>ui/-&gt;Cached</code> will draw the element to an image buffer. If the same element needs to be drawn again, it will instead just redraw the image buffer in the cache.</p><p>Drawing is usually pretty fast and overuse of <code>ui/-&gt;Cached</code> can make drawing performance worse, so use judiciously.</p><p>2. Provide an optimized drawing implementation</p><p>Backend implementations are allowed to do whatever they want, but they generally all follow the convention of creating an IDraw protocol (eg. <code>membrane.java2d/IDraw</code>) that provides drawing implementations that match the underlying graphics library. An optimized drawing implementation can be provided by creating a new view type that implements the corresponding IDraw protocol(s). Note that this method may couple an application to a particular graphics backend which may or may not be worth the trade-off.</p><p>3. Background Rendering</p><p>Background rendering is similar to using <code>ui/-&gt;Cached</code>, but allows rendering to happen off the main thread. Most backends offer a <code>save-image</code> function (eg. <code>membrane.java2d/save-image</code>) that will save an image to a file. The file can be viewed with <code>(ui/image image-path)</code>. Additionally, some backends provide a function to draw directly to an in memory image buffer (eg. <code>membrane.java2d/draw-to-image</code>).</p><p>Background rendering works well for dynamic or complicated drawings that might take several frames to compose. Background rendering is usually used in conjuection with some placeholder to show the user while the view is being built.</p><h2 id="Event-Handling">Event Handling</h2><p>Each event has a corresponding event function (eg. <code>membrane.ui/mouse-move</code>, <code>membrane.ui/mouse-down</code>) which means event handling can be profiled in isolation. Just call the relevant event function in a loop while running the profiler (eg. <code>(mouse-move my-view my-synthetic-event)</code>).</p><p>Membrane has a few optimizations for event handling, but most of the event functions can be thought of as having O(n) complexity. That means if there is a part of the view that has lots of child nodes, it may slow down all event handling, even if many of the child nodes don&apos;t have any event handlers attached.</p><p>The main culprit of laggy UIs is slow <code>mouse-move</code> event handlers. Since <code>mouse-move</code> events happen at a more frequent pace than other events, slow <code>mouse-move</code> event handlers can have a disproportionate impact on performance.</p><p>Another potential performance pitfall is overuse of <code>mouse-move-global</code> events. Whereas <code>mouse-move</code> will only search views under the cursor, <code>mouse-move-global</code> will search the whole view tree.</p><p>If it is known ahead of time that a complex view doesn&apos;t respond to any events, then the view can be wrapped with <code>membrane.ui/no-events</code>, which will effectively ignore that subset of the view tree when handling events.</p><p>If a complex view does need to respond to events, then it is easy to replace the event handler for that view by simply wrapping it in the corresponding event handler. A smarter algorithm can then be used to handle events for that subset of the tree. As an example, treemap-clj replaces the <code>mouse-move</code> and <code>mouse-down</code> events with an implementation that relies on a pre-calculated rtree,  <a href="https://github.com/phronmophobic/treemap-clj/blob/master/src/treemap_clj/view.cljc#L661">source</a>.</p><p>Below is a small example of replacing the event handler for a grid with a more efficient implementation.</p><div class="syntax"><pre>
<span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">wrap-grid-events</span> <span class="s-exp">[</span><span class="symbol">cell-size</span> <span class="symbol">grid</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/on</span>
   <span class="keyword">:mouse-move</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span> <span class="keyword">:as</span> <span class="symbol">mpos</span><span class="s-exp">]</span><span class="s-exp">]</span>
     <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:grid-hover</span> <span class="s-exp">(</span><span class="core-fn">long</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">mx</span> <span class="symbol">cell-size</span><span class="s-exp">)</span><span class="s-exp">)</span> <span class="s-exp">(</span><span class="core-fn">long</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">my</span> <span class="symbol">cell-size</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
   <span class="keyword">:mouse-down</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="s-exp">[</span><span class="symbol">mx</span> <span class="symbol">my</span> <span class="keyword">:as</span> <span class="symbol">mpos</span><span class="s-exp">]</span><span class="s-exp">]</span>
     <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:grid-select</span> <span class="s-exp">(</span><span class="core-fn">long</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">mx</span> <span class="symbol">cell-size</span><span class="s-exp">)</span><span class="s-exp">)</span> <span class="s-exp">(</span><span class="core-fn">long</span> <span class="s-exp">(</span><span class="core-fn">/</span> <span class="symbol">my</span> <span class="symbol">cell-size</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span>
   <span class="comment">;; ignore all other events for this view
</span>   <span class="s-exp">(</span><span class="symbol">ui/no-events</span> <span class="symbol">grid</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>


<span class="comment">;; usage
</span><span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">cell-size</span> <span class="number">2</span><span class="s-exp">)</span>
<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">grid</span>
  <span class="s-exp">(</span><span class="symbol">ui/->Cached</span>
   <span class="s-exp">(</span><span class="core-fn">vec</span>
    <span class="s-exp">(</span><span class="macro">for</span> <span class="s-exp">[</span><span class="symbol">x</span> <span class="s-exp">(</span><span class="core-fn">range</span> <span class="number">500</span><span class="s-exp">)</span>
          <span class="symbol">y</span> <span class="s-exp">(</span><span class="core-fn">range</span> <span class="number">500</span><span class="s-exp">)</span>
          <span class="keyword">:when</span> <span class="s-exp">(</span><span class="macro">and</span> <span class="s-exp">(</span><span class="core-fn">even?</span> <span class="symbol">x</span><span class="s-exp">)</span>
                     <span class="s-exp">(</span><span class="core-fn">even?</span> <span class="symbol">y</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">]</span>
      <span class="s-exp">(</span><span class="symbol">ui/translate</span> <span class="s-exp">(</span><span class="core-fn">*</span> <span class="symbol">x</span> <span class="symbol">cell-size</span><span class="s-exp">)</span> <span class="s-exp">(</span><span class="core-fn">*</span> <span class="symbol">y</span> <span class="symbol">cell-size</span><span class="s-exp">)</span>
                    <span class="s-exp">(</span><span class="symbol">ui/filled-rectangle</span> <span class="s-exp">[</span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span><span class="s-exp">]</span> <span class="symbol">cell-size</span> <span class="symbol">cell-size</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="special-form">def</span> <span class="symbol">grid-ui</span>
  <span class="s-exp">(</span><span class="symbol">ui/on</span>
   <span class="keyword">:grid-hover</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">gx</span> <span class="symbol">gy</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="core-fn">prn</span> <span class="string">"hover"</span> <span class="symbol">gx</span> <span class="symbol">gy</span><span class="s-exp">)</span><span class="s-exp">)</span>
   <span class="keyword">:grid-select</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">gx</span> <span class="symbol">gy</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="core-fn">prn</span> <span class="string">"select"</span> <span class="symbol">gx</span> <span class="symbol">gy</span><span class="s-exp">)</span><span class="s-exp">)</span>
   <span class="s-exp">(</span><span class="symbol">wrap-grid-events</span> <span class="symbol">cell-size</span> <span class="symbol">grid</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="s-exp">(</span><span class="symbol">skia/run</span> <span class="s-exp">(</span><span class="core-fn">constantly</span> <span class="symbol">grid-ui</span><span class="s-exp">)</span><span class="s-exp">)</span>

</pre></div><h3 id="Key-Events">Key Events</h3><p>Unlike mouse events which can be filtered by only searching views under the current mouse position, the only way to know if a view responds to key events is to search the whole tree to see if any view provides one of the key event handlers. Under the hood, membrane components will cache which components respond to key events and shortcut on future events. If your user interface doesn&apos;t add key event handlers, then this tip isn&apos;t something you need to worry about. However, if you do add key events, then you probably want to use either <code>membrane.ui/maybe-key-event</code> or <code>membrane.ui/maybe-key-press</code>. These macros will help membrane components cache which components respond to key events.</p><div class="syntax"><pre><span class="comment">;; don't do this
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">bad-view</span> <span class="s-exp">[</span><span class="symbol">focus?</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/on</span>
   <span class="keyword">:key-press</span>
   <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">s</span><span class="s-exp">]</span>
     <span class="s-exp">(</span><span class="conditional">when</span> <span class="symbol">focus?</span>
       <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:do-something!</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>

<span class="comment">;; do this instead
</span><span class="s-exp">(</span><span class="definition">defn</span> <span class="symbol">good-view</span> <span class="s-exp">[</span><span class="symbol">focus?</span><span class="s-exp">]</span>
  <span class="s-exp">(</span><span class="symbol">ui/maybe-key-press</span>
   <span class="symbol">focus?</span>
   <span class="s-exp">(</span><span class="symbol">ui/on</span>
    <span class="keyword">:key-press</span>
    <span class="s-exp">(</span><span class="special-form">fn</span> <span class="s-exp">[</span><span class="symbol">s</span><span class="s-exp">]</span>
      <span class="s-exp">[</span><span class="s-exp">[</span><span class="keyword">:do-something!</span><span class="s-exp">]</span><span class="s-exp">]</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span><span class="s-exp">)</span>
</pre></div><h2 id="Optimizing-Layout">Optimizing Layout</h2><p>Layout is pure function of view -&gt; view with elements moved around. As mentioned, the main tools for improving layout performance are memoization, using more efficient algorithms for the specific job, or moving the layout work off the main thread.</p></div></div></div></div></div></body></html>